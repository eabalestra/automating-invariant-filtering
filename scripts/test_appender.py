import os
import sys
import re
from typing import List

from file_manager import read_file, write_file
from utils import append_test_method_to_file
from test_compiler import get_compilable_tests
from test_extractor import extract_tests_from_file
from test_processor import replace_method_calling, add_augmented_to_constructor_subject, add_throws_declaration
from test_renamer import rename_classes_in_file, rename_test_methods
from code_extractor import extract_package_path


def prepare_destination_files(destination_test_driver: str, destination_test_suite: str) -> None:
    rename_classes_in_file(destination_test_suite)
    rename_classes_in_file(destination_test_driver)
    tester_class_name = os.path.basename(
        destination_test_suite).replace('Augmented.java', '')
    add_augmented_to_constructor_subject(
        destination_test_driver, tester_class_name)


def prepare_tests_for_compilation(tests, source_test_suite, subject_class) -> List[str]:
    print(f"Processing {len(tests)} tests from {source_test_suite}")

    subject_name = os.path.basename(subject_class).replace('.java', '')
    subject_package = extract_package_path(subject_class)

    renamed_tests = rename_test_methods(tests, 'llmTest')
    updated_tests = replace_method_calling(
        renamed_tests, subject_package, subject_name)

    return add_throws_declaration(updated_tests)


def append_generated_test_suite_to_original_test_suite(destination_test_suite, test_suite):
    for test in test_suite:
        append_test_method_to_file(destination_test_suite, test)


def append_tests_to_driver_file(file_path: str, test_methods: List[str]) -> None:
    content = read_file(file_path, 'r')
    if_block_pattern = r'if\s*\(\s*hadFailure\s*\)\s*\{'
    new_tests = "\n".join([
        f"""
        // Test generated by LLM
        try {{
            t0.{test}();
        }} catch (Throwable e) {{
            hadFailure = true;
            e.printStackTrace();
        }}
        """ for test in test_methods
    ])
    new_content = re.sub(if_block_pattern, new_tests + r'\g<0>', content)
    write_file(file_path, new_content, 'w')


def get_test_names_from_test_suite(test_suite):
    test_name_regex = r'public void (\w+)\(\)'
    compiled_test_names = [
        re.search(test_name_regex, test).group(1)
        for test in test_suite if re.search(test_name_regex, test)
    ]
    return compiled_test_names


def main() -> None:
    if len(sys.argv) < 4:
        print("Usage: python3 test_appender.py <destination_suite>.java <destination_driver>.java <source_suite>.java <subject_class>.java")
        sys.exit(1)

    destination_test_suite, destination_test_driver, source_test_suite, subject_class = sys.argv[
        1:5]

    test_suite = extract_tests_from_file(source_test_suite)
    if not test_suite:
        print(f"No tests found in {source_test_suite}")
        sys.exit(1)

    prepare_destination_files(destination_test_driver, destination_test_suite)

    syntax_repaired_tests = prepare_tests_for_compilation(
        test_suite, source_test_suite, subject_class)

    compiled_tests = get_compilable_tests(
        destination_test_suite, subject_class, syntax_repaired_tests)
    print(f"Compiled {len(compiled_tests)} tests from {source_test_suite}")
    append_generated_test_suite_to_original_test_suite(
        destination_test_suite, compiled_tests)

    compiled_test_names = get_test_names_from_test_suite(compiled_tests)
    append_tests_to_driver_file(destination_test_driver, compiled_test_names)


if __name__ == "__main__":
    main()
