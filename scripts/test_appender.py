import os
import sys
import re
from typing import List

from test_compiler import check_if_test_compiles
from test_extractor import extract_tests_from_file
from file_manager import read_file, write_file
from utils import append_test_method_to_file, extract_package_path


def rename_classes_in_file(file_path: str) -> None:
    content = read_file(file_path, 'r')
    pattern = r'(public\s+class\s+)(\w+)(\s*\{)'
    replacement = r'\1\2Augmented\3'
    new_content = re.sub(pattern, replacement, content)
    write_file(file_path, new_content, 'w')


def add_augmented_to_constructor_subject(file_path: str, subject_name: str) -> None:
    content = read_file(file_path, 'r')
    escaped_subject = re.escape(subject_name)
    pattern_regex = rf'\b({escaped_subject})(\b\s+\w+\s*=\s*new\s+)({escaped_subject})(\s*\()'
    replacement = r'\1Augmented\2\3Augmented\4'
    new_content = re.sub(pattern_regex, replacement, content)
    write_file(file_path, new_content, 'w')


def rename_test_methods(test_methods: List[str], new_name: str) -> List[str]:
    name_pattern = r'public void \w+\(\)'
    return [
        re.sub(name_pattern, f'public void {new_name}{i}()', test_method)
        for i, test_method in enumerate(test_methods)
    ]

# TODO: fix the cases like Sout() etc, que reemplaza.


def replace_method_calling(test_methods: List[str], subject_package: str) -> List[str]:
    constructor_pattern = r'new\s+(?!' + \
        re.escape(subject_package) + r'\.)([A-Z]\w*)\('
    static_call_pattern = r'(?<!' + \
        re.escape(subject_package) + r'\.)\b([A-Z]\w*)\.'
    type_declaration_pattern = r'(?<!@)(?<!' + \
        re.escape(subject_package) + r'\.)\b([A-Z]\w*)\b'

    updated_tests = []
    for test in test_methods:
        if not (re.search(constructor_pattern, test) or
                re.search(static_call_pattern, test) or
                re.search(type_declaration_pattern, test)):
            updated_tests.append(test)
        else:
            test = re.sub(constructor_pattern,
                          f'new {subject_package}.\\1(', test)
            test = re.sub(static_call_pattern,
                          f'{subject_package}.\\1.', test)
            test = re.sub(type_declaration_pattern,
                          f'{subject_package}.\\1', test)
            updated_tests.append(test)
    return updated_tests


def add_tests_to_driver_file(file_path: str, test_methods: list) -> None:
    content = read_file(file_path, 'r')
    if_block_pattern = r'if\s*\(\s*hadFailure\s*\)\s*\{'
    new_tests = "\n".join([
        f"""
        // Tests generated by LLM
        try {{
            t0.{test}();
        }} catch (Throwable e) {{
            hadFailure = true;
            e.printStackTrace();
        }}
        """ for test in test_methods
    ])
    new_content = re.sub(if_block_pattern, new_tests + r'\g<0>', content)
    write_file(file_path, new_content, 'w')


def process_tests(destination_test_file: str, test_driver_file: str, source_test_file: str, subject_file: str) -> None:
    tests = extract_tests_from_file(source_test_file)
    subject_package = extract_package_path(subject_file)

    rename_classes_in_file(destination_test_file)
    rename_classes_in_file(test_driver_file)

    tester_class_name = os.path.basename(
        destination_test_file).replace('Augmented.java', '')
    add_augmented_to_constructor_subject(test_driver_file, tester_class_name)

    if not tests:
        return

    renamed_tests = rename_test_methods(tests, 'llmTest')
    updated_tests = replace_method_calling(renamed_tests, subject_package)

    compiled_test_names = []
    for test_method in updated_tests:
        if check_if_test_compiles(destination_test_file, subject_file, test_method):
            append_test_method_to_file(destination_test_file, test_method)
            compiled_test_names.append(test_method)

    test_name_regex = r'public void (\w+)\(\)'
    compiled_test_names = [
        re.search(test_name_regex, test).group(1)
        for test in compiled_test_names if re.search(test_name_regex, test)
    ]
    add_tests_to_driver_file(test_driver_file, compiled_test_names)


def main() -> None:
    if len(sys.argv) < 4:
        print("Usage: python script.py <destination_test_file> <destination_test_driver_file> <source_test_file> <subject_file>")
        sys.exit(1)

    destination_test_file, test_driver_file, source_test_file, subject_file = sys.argv[1:5]
    process_tests(destination_test_file, test_driver_file,
                  source_test_file, subject_file)


if __name__ == "__main__":
    main()
